## ../socket
### ソケット通信の基本構造
ソケット通信の基本的な構成は以下のようになる。  
- サーバー：ソケットを開いて待ち受ける。
- クライアント：開いているソケットに接続し、通信を行う。  

Goの場合、サーバーは`Listen()`メソッド、クライアントは`Dial()`メソッドで呼ぶとAPIで決まっている。

`net.Conn`は`io.Reader`、`io.Writer`、`io.Closer`にタイムアウトを設定するメソッドを追加したインターフェース。通信が確定すると送信側と受信側に相手との通信を行うための`net.Conn`インターフェースを満たすオブジェクトが渡ってくる。

##### TCPのクライアントコード
```go
conn, err := net.Dial("tcp", "localhost:8080")
if err != nil {
    panic(err)
}
// connを使った読み書き
```

##### サーバー側の最低限のコード
```go
ln, err := net.Listen("tcp", "localhost:8080")
if err != nil {
    panic(err)
}
conn, err := ln.Accept()
if err != nil {
    //handle error
}
//connを使った読み書き
```
これでサーバとして応答はできるが一度アクセスされたら終了するので、「実装が簡単で、秒間に処理できるレスポンス数が極めて高い」サーバの最低限のサーバは以下のようになる。
```go
ln, err := net.Listen("tcp", ":8080")
if err != nil {
    panic(err)
}
//一度で終了しないためにAccept()を何度も呼ぶ
for {
    conn, err := ln.Accept()
    if err != nil {
        // handle err 
    }
    //1リクエスト処理中に他のリクエストのAccept()が行えるように
    //Goroutineを使って非同期にレスポンスを処理する。
    go func() {
        //conn を使った読み書き
    }()
}
```

----
>実際にGo言語でHTTPのコードを作成するときは、`net/http`以下の高機能なAPIを使う。
### HTTP/1.0のコード
- **a.go** [server]  
TCPソケットを使ったHTTPサーバ  
Goのソケットを使ってHTTP/1.0相当の送受信をする。

- **b.go** [client]
TCPソケットを使ったHTTPクライアント  


### Keep-Alive対応のHTTPサーバ
HTTP/1.1では`Keep-Alive`が規格に入った。これにより、HTTP/1.0のように1つのメッセージごとに切断するのではなく、しばらくの間はTCP接続のセッションを維持して使い回す。TCPでは、セッションを接続するのに1.5 RTT（ラウンドトリップタイム：1往復の通信で1 RTT）の時間がかかり、セッションの切断にも1.5 RTTの時間がかかる。

物理的な距離や回線速度などで1 RTTの時間は変わるが、RTTが多ければ通信速度に直接の影響を与える。一度の送信（送信と確認の返信で1 RTT）につき1.5 + 1.5 = 3 RTT のオーバーヘッドがあれば、実行速度は単運に1/4になる。Keep-Aliveを使えば、この分のオーバーヘッドが無くせるため、速度の低下を防げる。

### HTTP/1.1のコード
- **c.go** [server]  
Keep-Alive対応のHTTPサーバ  
このコードで重要なのはAccept()を受信したあとにforループがある点、これにより、コネクションが張られた後に何度もリクエストを受けられるようにする。また、タイムアウトの設定をすると、通信がしばらくないとタイムアウトのエラーでRead()の呼び出しを終了する。設定しないと相手からレスポンスがあるまでずっとブロックし続ける。タイムアウトは標準の`error`インターフェースの上位互換である`net.Error`インターフェースの構造体から取得できる。タイムアウト時のエラーは`net.Conn`が生成するが、それ以外の`io.Reader`は最初に発生したエラーをそのまま伝搬する。そのため、errorからダウンキャストを行うことでタイムアウトかどうかを判断することができる。

- **d.go** [client]  
Keep-Alive対応のHTTPクライアント  
簡単可のため、送信メッセージを予め配列に入れておいてその送信が終わったら終了というコードになっている。

サーバ同様、一度通信を開始したソケットはなるべく再利用する。サーバー側と異なるのは、通信の起点はソケットなので、セッションが切れた場合の再接続はクライアント側にあるという点。切れた場合は`net.Conn`型の変数を一度クリアして再試行するようになっている。